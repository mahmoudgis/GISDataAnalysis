<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>محلل البيانات الجغرافية</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React Libraries -->
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    
    <!-- Babel to transpile JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="root"></div>

    <script type="text/babel">
        // The entire React application code goes here.
        const { useState, useCallback, useEffect, useRef } = React;

        // Helper function to load scripts dynamically
        const loadScript = (src) => {
          return new Promise((resolve, reject) => {
            if (document.querySelector(`script[src="${src}"]`)) {
              resolve();
              return;
            }
            const script = document.createElement('script');
            script.src = src;
            script.onload = () => resolve();
            script.onerror = () => reject(new Error(`Script load error for ${src}`));
            document.head.appendChild(script);
          });
        };
        
        // --- Statistical Calculation Function ---
        const calculateStats = (properties) => {
            if (!properties || properties.length === 0) return {};

            const stats = {};
            const allKeys = new Set();
            properties.forEach(p => {
                if (p) {
                    Object.keys(p).forEach(k => allKeys.add(k));
                }
            });
            const keys = Array.from(allKeys);
            const totalRecords = properties.length;

            keys.forEach(key => {
                const values = properties.map(p => p ? p[key] : null).filter(v => v != null && v !== '');
                
                const missingCount = totalRecords - values.length;
                const completeness = ((values.length / totalRecords) * 100).toFixed(1);

                if (values.length === 0) {
                     stats[key] = { type: 'فارغ', count: 0, missing: missingCount, completeness: completeness, uniqueValues: 0 };
                     return;
                }

                const numericValues = values.map(Number).filter(n => !isNaN(n));
                const isNumeric = numericValues.length / values.length > 0.8;
                const uniqueCount = new Set(values).size;

                if (isNumeric && numericValues.length > 0) {
                    const count = numericValues.length;
                    const sum = numericValues.reduce((a, b) => a + b, 0);
                    const mean = sum / count;
                    const min = Math.min(...numericValues);
                    const max = Math.max(...numericValues);
                    const stdDev = Math.sqrt(numericValues.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / count);
                    stats[key] = {
                        type: 'رقمي',
                        count,
                        mean: parseFloat(mean.toFixed(2)),
                        stdDev: parseFloat(stdDev.toFixed(2)),
                        min,
                        max,
                        missing: missingCount,
                        completeness: completeness,
                        uniqueValues: uniqueCount
                    };
                } else {
                    const valueCounts = values.reduce((acc, val) => {
                        const valStr = String(val);
                        acc[valStr] = (acc[valStr] || 0) + 1;
                        return acc;
                    }, {});

                    const top5 = Object.entries(valueCounts)
                        .sort(([, a], [, b]) => b - a)
                        .slice(0, 5)
                        .reduce((obj, [key, value]) => ({ ...obj, [key]: value }), {});

                    stats[key] = {
                        type: 'نصي/فئوي',
                        count: values.length,
                        uniqueValues: uniqueCount,
                        top5Frequencies: top5,
                        missing: missingCount,
                        completeness: completeness
                    };
                }
            });
            return stats;
        };

        // Function to calculate spatial distribution summary
        const calculateSpatialDistribution = (geojson) => {
            if (!geojson || geojson.features.length < 20) {
                return "لا يتم حساب التوزيع للبيانات الصغيرة.";
            }

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const points = [];

            geojson.features.forEach(feature => {
                if (feature.geometry && feature.geometry.coordinates) {
                    let x, y;
                    if (feature.geometry.type === 'Point') {
                        [x, y] = feature.geometry.coordinates;
                    } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                        const coords = feature.geometry.coordinates.flat(Infinity);
                        let sumX = 0, sumY = 0;
                        let count = 0;
                        for (let i = 0; i < coords.length; i += 2) {
                            sumX += coords[i];
                            sumY += coords[i+1];
                            count++;
                        }
                        if(count > 0) {
                            x = sumX / count;
                            y = sumY / count;
                        }
                    } else {
                        return;
                    }

                    if (isNaN(x) || isNaN(y)) return;

                    points.push({x, y});
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                }
            });

            if (points.length === 0) return "لا يمكن تحديد التوزيع المكاني.";

            const gridSize = 10;
            const grid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
            const cellWidth = (maxX - minX) / gridSize;
            const cellHeight = (maxY - minY) / gridSize;

            if (cellWidth === 0 || cellHeight === 0) {
                return "البيانات تتركز في موقع واحد أو على امتداد خطي.";
            }

            points.forEach(point => {
                const gridX = Math.min(Math.floor((point.x - minX) / cellWidth), gridSize - 1);
                const gridY = Math.min(Math.floor((point.y - minY) / cellHeight), gridSize - 1);
                grid[gridY][gridX]++;
            });

            const cellData = [];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x] > 0) {
                        cellData.push({ count: grid[y][x], x, y });
                    }
                }
            }

            cellData.sort((a, b) => b.count - a.count);

            if (cellData.length === 0) return "لم يتم العثور على نمط توزيع واضح.";

            const totalPoints = points.length;
            const topCells = cellData.slice(0, 3);

            const describeLocation = (x, y) => {
                let yDesc = y < 3 ? "جنوب" : y > 6 ? "شمال" : "منتصف";
                let xDesc = x < 3 ? "غرب" : x > 6 ? "شرق" : "وسط";
                
                if (yDesc === "منتصف" && xDesc === "وسط") return "في المركز";
                if (yDesc === "منتصف") return `في الجزء ال${xDesc}ي`;
                if (xDesc === "وسط") return `في الجزء ال${yDesc}ي`;
                
                return `في الجزء ال${yDesc}ي ال${xDesc}ي`;
            };

            let summary = `يوجد تمركز للظاهرات في المناطق التالية من الامتداد المكاني للبيانات:\n`;
            topCells.forEach(cell => {
                const percentage = ((cell.count / totalPoints) * 100).toFixed(1);
                summary += `- تمركز ملحوظ ${describeLocation(cell.x, cell.y)}، حيث يحتوي على حوالي ${percentage}% من إجمالي الظاهرات.\n`;
            });
            
            const populatedCells = cellData.length;
            const totalCells = gridSize * gridSize;
            if ((populatedCells / totalCells) > 0.7) {
                summary += "\nبشكل عام، تظهر البيانات انتشارًا واسعًا عبر المنطقة مع وجود بعض التكتلات المذكورة أعلاه.";
            } else {
                summary += "\nتتركز البيانات بشكل كبير في هذه المناطق مع وجود مناطق أخرى قليلة الكثافة.";
            }

            return summary;
        };


        const App = () => {
          // State management
          const [fileInfo, setFileInfo] = React.useState(null);
          const [aiResponse, setAiResponse] = React.useState('');
          const [isLoading, setIsLoading] = React.useState(false);
          const [isAiLoading, setIsAiLoading] = React.useState(false);
          const [error, setError] = React.useState('');
          const [isDragging, setIsDragging] = React.useState(false);
          const [scriptsLoaded, setScriptsLoaded] = React.useState(false);
          const [isCopied, setIsCopied] = React.useState(false);
          const [userDescription, setUserDescription] = React.useState('');
          const [uploadedFile, setUploadedFile] = React.useState(null);
          
          const ProgressBar = ({ text }) => {
            return (
                <div className="w-full bg-sky-100 rounded-full p-2">
                    <div className="bg-sky-200 rounded-full">
                        <div 
                            className="bg-gradient-to-r from-sky-400 to-blue-500 h-4 rounded-full animate-progress"
                            style={{ width: '100%' }}
                        ></div>
                    </div>
                    <p className="text-center text-sm text-sky-800 mt-2">{text}</p>
                </div>
            );
          };

          const SimpleMarkdownRenderer = ({ text }) => {
            if (!text) return null;

            const parseLine = (line) => {
                return line.replace(/\*\*(.*?)\*\*/g, '<strong class="font-bold text-slate-800">$1</strong>')
                           .replace(/`(.*?)`/g, '<span class="text-blue-600 font-mono">$1</span>');
            };

            const blocks = text.split('\n\n'); 

            return (
                <div className="leading-relaxed">
                    {blocks.map((block, blockIndex) => {
                        const lines = block.split('\n');
                        const isList = lines.every(line => line.trim().startsWith('- '));

                        if (isList) {
                            return (
                                <ul key={blockIndex} className="list-disc pr-6 space-y-1 mt-2 mb-4">
                                    {lines.map((item, itemIndex) => (
                                        <li key={itemIndex} dangerouslySetInnerHTML={{ __html: parseLine(item.trim().substring(2)) }} />
                                    ))}
                                </ul>
                            );
                        }

                        return (
                            <div key={blockIndex}>
                                {lines.map((line, lineIndex) => {
                                    if (line.startsWith('## ')) {
                                        return <h2 key={lineIndex} className="text-2xl font-bold text-sky-900 mt-4 mb-2" dangerouslySetInnerHTML={{ __html: parseLine(line.substring(3)) }} />;
                                    }
                                    if (line.startsWith('### ')) {
                                        return <h3 key={lineIndex} className="text-xl font-bold text-sky-800 mt-3 mb-1" dangerouslySetInnerHTML={{ __html: parseLine(line.substring(4)) }} />;
                                    }
                                    return <p key={lineIndex} className="my-2" dangerouslySetInnerHTML={{ __html: parseLine(line) }} />;
                                })}
                            </div>
                        );
                    })}
                </div>
            );
          };

          const SummaryChart = ({ summary }) => {
            if (!summary || Object.keys(summary).length === 0) return null;

            const generateSVG = () => {
                const entries = Object.entries(summary);
                if (entries.length === 0) return '';

                const width = 600;
                const chartHeight = 250;
                const barWidth = 40;
                const groupMargin = 20;
                const labelAreaHeight = 120;
                const startX = 50; // Left padding for Y-axis labels
                const totalWidth = entries.length * (barWidth + groupMargin) + startX;

                let svgContent = `<svg width="100%" viewBox="0 0 ${totalWidth} ${chartHeight + labelAreaHeight}" xmlns="http://www.w3.org/2000/svg">
                    <style>
                        .label { font-family: Arial, sans-serif; font-size: 12px; fill: #333; text-anchor: middle; }
                        .bar-completeness { fill: #3b82f6; }
                        .axis { stroke: #9ca3af; stroke-width: 1; }
                        .grid-line { stroke: #e5e7eb; stroke-width: 1; }
                        .percent-label { font-family: Arial, sans-serif; font-size: 10px; fill: #fff; text-anchor: middle; }
                    </style>
                    
                    <line x1="${startX - 10}" y1="0" x2="${startX - 10}" y2="${chartHeight}" class="axis" />
                    <line x1="${startX - 10}" y1="${chartHeight}" x2="${totalWidth}" y2="${chartHeight}" class="axis" />
                `;

                for(let i = 0; i <= 4; i++) {
                    const y = chartHeight * (1 - i/4);
                    const value = i * 25;
                    svgContent += `
                        <text x="${startX - 15}" y="${y + 4}" text-anchor="end" font-size="10" fill="#6b7280">${value}%</text>
                        <line x1="${startX - 10}" y1="${y}" x2="${totalWidth}" y2="${y}" class="grid-line" />
                    `;
                }

                entries.forEach(([key, value], index) => {
                    const groupX = index * (barWidth + groupMargin) + startX + (groupMargin / 2);
                    const barH = (value.completeness / 100) * chartHeight;

                    svgContent += `
                        <g>
                            <rect x="${groupX}" y="${chartHeight - barH}" width="${barWidth}" height="${barH}" class="bar-completeness" rx="2" />
                            <text x="${groupX + barWidth / 2}" y="${chartHeight - barH - 5}" class="label">${value.completeness}%</text>
                            <text x="${groupX + barWidth / 2}" y="${chartHeight + 20}" transform="rotate(65, ${groupX + barWidth / 2}, ${chartHeight + 20})" class="label">${key}</text>
                        </g>
                    `;
                });
                svgContent += `</svg>`;
                return svgContent;
            };

            return (
                <div className="bg-white p-6 rounded-xl shadow-md border border-gray-200 animate-fade-in">
                    <h2 className="text-2xl font-bold text-gray-800 mb-4">ملخص اكتمال المتغيرات</h2>
                    <div dangerouslySetInnerHTML={{ __html: generateSVG() }} />
                </div>
            );
          };

          // Load external libraries and styles on component mount
          React.useEffect(() => {
            Promise.all([
              loadScript('https://unpkg.com/shpjs@latest/dist/shp.js'),
              loadScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js'),
              loadScript('https://cdnjs.cloudflare.com/ajax/libs/togeojson/0.16.0/togeojson.js'),
            ]).then(() => {
              console.log("All libraries loaded successfully.");
              setScriptsLoaded(true);
            }).catch(err => {
              console.error(err);
              setError('فشل في تحميل المكتبات اللازمة. يرجى تحديث الصفحة.');
            });

            const styleId = 'geospatial-app-styles';
            if (!document.getElementById(styleId)) {
                const style = document.createElement('style');
                style.id = styleId;
                style.innerHTML = `
                  @keyframes fade-in {
                    from { opacity: 0; transform: translateY(10px); }
                    to { opacity: 1; transform: translateY(0); }
                  }
                  .animate-fade-in {
                    animation: fade-in 0.5s ease-out forwards;
                  }
                  @keyframes progress-animation {
                    0% { background-position: 200% 0; }
                    100% { background-position: -200% 0; }
                  }
                  .animate-progress {
                    background-size: 200% 100%;
                    animation: progress-animation 2s linear infinite;
                  }
                `;
                document.head.appendChild(style);
            }
          }, []);

          // --- File Processing Functions (now return promises) ---
          const processGeoJSON = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const geojson = JSON.parse(e.target.result);
                        if (!geojson.features || !geojson.type) {
                            reject(new Error('Invalid GeoJSON structure'));
                        }
                        resolve(geojson);
                    } catch (err) {
                        reject(err);
                    }
                };
                reader.onerror = () => reject(new Error('Failed to read GeoJSON file.'));
                reader.readAsText(file);
            });
          };

          const processShapefile = (file) => {
             return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const buffer = e.target.result;
                        const geojson = await window.shp.parseZip(buffer);
                        resolve(geojson);
                    } catch (err) {
                        reject(err);
                    }
                };
                reader.onerror = () => reject(new Error('Failed to read Shapefile.'));
                reader.readAsArrayBuffer(file);
            });
          };

          const processKML = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const kmlText = e.target.result;
                        const dom = new DOMParser().parseFromString(kmlText, 'text/xml');
                        if (dom.getElementsByTagName('parsererror').length) {
                            reject(new Error('KML parsing error.'));
                        }
                        const geojson = window.toGeoJSON.kml(dom);
                        resolve(geojson);
                    } catch (err) {
                        reject(err);
                    }
                };
                reader.onerror = () => reject(new Error('Failed to read KML file.'));
                reader.readAsText(file);
            });
          };

          const processKMZ = (file) => {
             return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const buffer = e.target.result;
                        const zip = await window.JSZip.loadAsync(buffer);
                        const kmlFile = Object.values(zip.files).find(f => f.name.toLowerCase().endsWith('.kml'));

                        if (!kmlFile) {
                            reject(new Error('No .kml file found inside the KMZ archive.'));
                        }

                        const kmlText = await kmlFile.async('string');
                        const dom = new DOMParser().parseFromString(kmlText, 'text/xml');
                        if (dom.getElementsByTagName('parsererror').length) {
                            reject(new Error('KML parsing error inside KMZ.'));
                        }
                        const geojson = window.toGeoJSON.kml(dom);
                        resolve(geojson);
                    } catch (err) {
                        reject(err);
                    }
                };
                reader.onerror = () => reject(new Error('Failed to read KMZ file.'));
                reader.readAsArrayBuffer(file);
            });
          };

          // --- Geographic Context Calculation with KM distance ---
          const getGeographicContext = async (geojson) => {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            const getCoords = (geom) => {
                if (!geom || !geom.coordinates) return [];
                if (geom.type === 'Point') return [geom.coordinates];
                if (geom.type === 'LineString' || geom.type === 'MultiPoint') return geom.coordinates;
                if (geom.type === 'Polygon' || geom.type === 'MultiLineString') return geom.coordinates.flat();
                if (geom.type === 'MultiPolygon') return geom.coordinates.flat(2);
                return [];
            };

            const allCoords = geojson.features.flatMap(f => getCoords(f.geometry));

            if (allCoords.length === 0) {
                return { centerLocation: "غير معروف", extent: "غير معروف" };
            }

            allCoords.forEach(coord => {
                const [x, y] = coord;
                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
            });

            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;

            const haversineDistance = (coords1, coords2) => {
                const [lon1, lat1] = coords1;
                const [lon2, lat2] = coords2;
                const R = 6371; // Earth's radius in km
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                          Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            };

            const widthKm = haversineDistance([minX, minY], [maxX, minY]);
            const heightKm = haversineDistance([minX, minY], [minX, maxY]);
            const extentInKm = `يمتد على مساحة تقريبية عرضها ${widthKm.toFixed(2)} كم وطولها ${heightKm.toFixed(2)} كم.`;

            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${centerY}&lon=${centerX}&zoom=10`);
                if (!response.ok) throw new Error('Reverse geocoding failed');
                const data = await response.json();
                const centerLocation = data.display_name || "موقع غير محدد";
                return { centerLocation, extent: extentInKm };
            } catch (error) {
                console.error("Geocoding error:", error);
                return { centerLocation: "فشل تحديد الموقع", extent: extentInKm };
            }
          };

          // --- Data Summarization and AI Prompt Generation ---
          const summarizeData = async (geojson) => {
            try {
                if (!geojson || !geojson.features || geojson.features.length === 0) {
                    throw new Error('الملف لا يحتوي على أي معالم (features) قابلة للعرض.');
                }

                const firstFeature = geojson.features[0];
                const allProperties = geojson.features.map(feature => feature.properties);
                const statisticalSummary = calculateStats(allProperties);
                const geographicContext = await getGeographicContext(geojson);
                const spatialDistribution = calculateSpatialDistribution(geojson);

                const summary = {
                    featureCount: geojson.features.length,
                    geometryType: firstFeature.geometry ? firstFeature.geometry.type : 'N/A',
                    attributes: firstFeature.properties ? Object.keys(firstFeature.properties) : [],
                    statisticalSummary: statisticalSummary,
                    geographicContext: geographicContext,
                    spatialDistribution: spatialDistribution,
                    userDescription: userDescription
                };
                
                setFileInfo(summary);
                await generateAiInsight(summary);
            } catch (err) {
                throw err; // Propagate error up
            }
          };

          const generateAiInsight = async (summary) => {
              setIsAiLoading(true);
              setAiResponse('');
              setIsCopied(false);

              const prompt = `
You are an expert GIS data analyst. Your task is to analyze the following summary of a geospatial dataset and provide a detailed, insightful description in ARABIC using Markdown formatting.

**IMPORTANT TERMINOLOGY & FORMATTING**:
- Use "الخصائص الوصفية" for the general concept of attributes.
- When referring to a specific column/field in the attribute table, use "المتغير".
- Use "المساحي" for polygons (e.g., "شكل مساحي" or "بيانات مساحية").
- Use "ظاهرة جغرافية" instead of "كيان جغرافي".
- Use "ظاهرات" or "عناصر" instead of "الكيانات" or "الكيان".
- When referring to a single polygon feature, use "ظاهرة مساحية واحدة".
- **Use Markdown for structure:**
  - Use '##' for main headings.
  - Use '###' for sub-headings.
  - Use '-' for bullet points.
  - Use '**' for bolding key terms.
- **Do not use backticks (\`) or parentheses () for emphasis. Instead, highlight key terms by making them bold.**

**CRITICAL: Use the provided "Geographic Context" AND "Spatial Distribution Summary" to make your analysis spatially aware. The analysis of spatial patterns is based on the FULL dataset, not a sample.**
**Also, use the "User's Description" as a key piece of context to guide your analysis.**

**Base your analysis on ALL provided information.** Do not guess.

**NEW SECTION: Add a dedicated section '## تحليل جودة البيانات' to your analysis. Use subheadings (###) for the following points:**
- ### الاكتمال
- ### الاتساق
- ### الصحة والقيم الشاذة

**Your Detailed Analysis (in ARABIC Markdown):**
`;

              try {
                const fixedApiKey = "AIzaSyAiXPFur5FiFdnxD5A8b5Cw2xH1VkppiOA";
                if (!fixedApiKey) {
                    throw new Error("مفتاح API غير متوفر.");
                }
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${fixedApiKey}`;
                
                const payload = {
                  contents: [{ role: "user", parts: [{ text: prompt }, {text: `**User's Description:**\n${summary.userDescription || 'لم يقدم المستخدم وصفًا.'}\n\n**Dataset Summary:**\n- **Feature Count:** ${summary.featureCount}\n- **نوع الظاهرات:** ${summary.geometryType}\n\n**Geographic Context:**\n- **Approximate Center:** ${summary.geographicContext.centerLocation}\n- **Spatial Extent:** ${summary.geographicContext.extent}\n\n**Spatial Distribution Summary:**\n${summary.spatialDistribution}\n\n**Statistical Summary of Attributes:**\n${JSON.stringify(summary.statisticalSummary, null, 2)}`}] }]
                };

                const response = await fetch(apiUrl, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(payload)
                });

                if (!response.ok) {
                  const errorBody = await response.json();
                  console.error("AI API Error:", errorBody);
                  throw new Error(`AI service returned an error: ${errorBody.error?.message || response.statusText}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    const generatedText = result.candidates[0].content.parts[0].text;
                    setAiResponse(generatedText.trim());
                } else {
                    throw new Error("لم يتمكن الذكاء الاصطناعي من إنشاء وصف.");
                }

              } catch (err) {
                  console.error(err);
                  setError(`فشل الاتصال بخدمة الذكاء الاصطناعي: ${err.message}`);
                  setAiResponse('');
              } finally {
                  setIsAiLoading(false);
              }
          };

          const handleCopy = () => {
            if (!aiResponse) return;
            const textarea = document.createElement('textarea');
            textarea.value = aiResponse;
            textarea.style.position = 'fixed';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                setIsCopied(true);
                setTimeout(() => setIsCopied(false), 2000);
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
            document.body.removeChild(textarea);
          };

          const handleExportToWord = () => {
            if (!fileInfo || !aiResponse) return;

            const generateSummaryChartSVG = (summary) => {
                const entries = Object.entries(summary);
                if (entries.length === 0) return '';

                const width = 600;
                const chartHeight = 250;
                const barWidth = 40;
                const groupMargin = 20;
                const labelAreaHeight = 120;
                const startX = 50;
                const totalWidth = entries.length * (barWidth + groupMargin) + startX;

                let svgContent = `<svg width="${totalWidth}" height="${chartHeight + labelAreaHeight}" xmlns="http://www.w3.org/2000/svg">
                    <style>
                        .label { font-family: Arial, sans-serif; font-size: 12px; fill: #333; text-anchor: middle; }
                        .bar-completeness { fill: #3b82f6; }
                        .axis { stroke: #9ca3af; stroke-width: 1; }
                        .grid-line { stroke: #e5e7eb; stroke-width: 1; }
                    </style>
                    <line x1="${startX - 10}" y1="0" x2="${startX - 10}" y2="${chartHeight}" class="axis" />
                    <line x1="${startX - 10}" y1="${chartHeight}" x2="${totalWidth}" y2="${chartHeight}" class="axis" />
                `;

                for(let i = 0; i <= 4; i++) {
                    const y = chartHeight * (1 - i/4);
                    const value = i * 25;
                    svgContent += `
                        <text x="${startX - 15}" y="${y + 4}" text-anchor="end" font-size="10" fill="#6b7280">${value}%</text>
                        <line x1="${startX - 10}" y1="${y}" x2="${totalWidth}" y2="${y}" class="grid-line" />
                    `;
                }

                entries.forEach(([key, value], index) => {
                    const groupX = index * (barWidth + groupMargin) + startX + (groupMargin / 2);
                    const barH = (value.completeness / 100) * chartHeight;
                    svgContent += `
                        <g>
                            <rect x="${groupX}" y="${chartHeight - barH}" width="${barWidth}" height="${barH}" class="bar-completeness" rx="2" />
                            <text x="${groupX + barWidth / 2}" y="${chartHeight - barH - 5}" class="label">${value.completeness}%</text>
                            <text x="${groupX + barWidth / 2}" y="${chartHeight + 20}" transform="rotate(65, ${groupX + barWidth / 2}, ${chartHeight + 20})" class="label">${key}</text>
                        </g>
                    `;
                });
                svgContent += `</svg>`;
                return svgContent;
            };

            const markdownToHtml = (text) => {
                let html = text
                    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                    .replace(/^- (.*$)/gim, (match, p1) => `<ul><li>${p1.trim()}</li></ul>`)
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/`(.*?)`/g, '<span style="color: #059669; font-family: monospace;">$1</span>');
                
                html = html.replace(/<\/ul>\s*<ul>/g, '');
                
                const lines = html.split('\n');
                return lines.map(line => line.startsWith('<h2>') || line.startsWith('<h3>') || line.startsWith('<ul>') ? line : `<p>${line}</p>`).join('');
            };
            
            let reportHtml = ``;

            if (userDescription) {
                reportHtml += `
                    <h2>وصف المستخدم للبيانات</h2>
                    <p>${userDescription}</p>
                    <br/>
                `;
            }

            reportHtml += `
                <h2>ملخص البيانات الهيكلية</h2>
                <p><strong>عدد الظاهرات:</strong> ${fileInfo.featureCount}</p>
                <p><strong>نوع الظاهرات:</strong> ${fileInfo.geometryType}</p>
                <br/>
            `;

            if (fileInfo.geographicContext) {
                reportHtml += `
                    <h2>السياق الجغرافي</h2>
                    <p><strong>المركز التقريبي للبيانات:</strong> ${fileInfo.geographicContext.centerLocation}</p>
                    <p><strong>الامتداد المكاني:</strong> ${fileInfo.geographicContext.extent}</p>
                    <br/>
                `;
            }

            if (fileInfo.statisticalSummary && Object.keys(fileInfo.statisticalSummary).length > 0) {
                reportHtml += `<h2>الملخص الإحصائي للمتغيرات</h2>`;
                 Object.entries(fileInfo.statisticalSummary).forEach(([key, value]) => {
                    reportHtml += `<h3>${key} <span style="color: #059669;">${value.type}</span></h3>`;
                    if (value.type === 'رقمي') {
                        reportHtml += `<ul>
                            <li><strong>العدد:</strong> ${value.count}</li>
                            <li><strong>المتوسط:</strong> ${value.mean}</li>
                            <li><strong>الانحراف المعياري:</strong> ${value.stdDev}</li>
                            <li><strong>أقل قيمة:</strong> ${value.min}</li>
                            <li><strong>أعلى قيمة:</strong> ${value.max}</li>
                            <li><strong>الاكتمال:</strong> ${value.completeness}%</li>
                        </ul>`;
                    } else if (value.type === 'نصي/فئوي') {
                        reportHtml += `<ul>
                            <li><strong>العدد:</strong> ${value.count}</li>
                            <li><strong>القيم الفريدة:</strong> ${value.uniqueValues}</li>
                            <li><strong>الاكتمال:</strong> ${value.completeness}%</li>
                            <li><strong>أعلى 5 قيم تكراراً:</strong><ul>`;
                        if (value.top5Frequencies) {
                            Object.entries(value.top5Frequencies).forEach(([k, v]) => {
                                reportHtml += `<li>"${k}": ${v} مرة</li>`;
                            });
                        }
                        reportHtml += `</ul></li></ul>`;
                    }
                });
                reportHtml += `<br/>`;

                reportHtml += `<h2>ملخص اكتمال المتغيرات</h2>`;
                const summaryChartSVG = generateSummaryChartSVG(fileInfo.statisticalSummary);
                if(summaryChartSVG) {
                    const svgEncoded = btoa(unescape(encodeURIComponent(summaryChartSVG)));
                    reportHtml += `<p><img src="data:image/svg+xml;base64,${svgEncoded}" alt="Summary Chart" /></p><br/>`;
                }
            }

            reportHtml += `
                <h2>تحليل الذكاء الاصطناعي</h2>
                ${markdownToHtml(aiResponse)}
            `;

            const fullHtml = `
                <!DOCTYPE html>
                <html dir="rtl" xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'>
                <head>
                    <meta charset="UTF-8">
                    <!--[if gte mso 9]><xml><w:WordDocument><w:View>Print</w:View><w:Zoom>90</w:Zoom><w:DoNotOptimizeForBrowser/><w:Rtl/></w:WordDocument></xml><![endif]-->
                    <style>
                        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; direction: rtl; text-align: right; }
                        h1 { font-size: 24px; color: #172554; border-bottom: 2px solid #60a5fa; padding-bottom: 5px;}
                        h2 { font-size: 20px; color: #1e3a8a; margin-top: 20px; }
                        h3 { font-size: 16px; color: #1d4ed8; margin-top: 15px; }
                        ul { list-style-type: disc; margin-right: 40px; }
                        p, li { font-size: 14px; line-height: 1.6; }
                        strong { color: #374151; }
                    </style>
                </head>
                <body>
                    <h1>تقرير تحليل البيانات الجغرافية</h1>
                    ${reportHtml}
                </body>
                </html>
            `;

            const blob = new Blob(['\ufeff', fullHtml], {
                type: 'application/msword'
            });
            
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'تقرير_البيانات_الجغرافية.doc';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
          };


          const handleFileChange = React.useCallback((files) => {
            if (!scriptsLoaded) {
                setError("المكتبات لم تحمل بعد، يرجى الانتظار قليلاً.");
                return;
            }
            if (!files || files.length === 0) return;
            const file = files[0];
            
            // Reset everything
            setError('');
            setFileInfo(null);
            setAiResponse('');
            setUploadedFile(file);
          }, [scriptsLoaded]);

          // Function to start the analysis, triggered by the button
          const handleStartAnalysis = async () => {
            if (!uploadedFile) {
                setError("يرجى رفع ملف أولاً.");
                return;
            }

            setIsLoading(true);
            setError('');
            setFileInfo(null);
            setAiResponse(null);

            try {
                const extension = uploadedFile.name.split('.').pop().toLowerCase();
                let geojson;

                if (extension === 'zip') { geojson = await processShapefile(uploadedFile); } 
                else if (extension === 'kml') { geojson = await processKML(uploadedFile); } 
                else if (extension === 'kmz') { geojson = await processKMZ(uploadedFile); } 
                else if (extension === 'geojson' || extension === 'json') { geojson = await processGeoJSON(uploadedFile); } 
                else {
                    throw new Error(`نوع الملف (${extension}) غير مدعوم.`);
                }
                
                await summarizeData(geojson);

            } catch (err) {
                console.error(err);
                setError(`فشل في معالجة الملف: ${err.message}`);
            } finally {
                setIsLoading(false);
            }
          };

          const handleDragOver = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(true); };
          const handleDragLeave = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); };
          const handleDrop = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); handleFileChange(e.dataTransfer.files); };

          return (
            <div dir="rtl" className="bg-gray-50 min-h-screen font-sans text-gray-800 p-4 sm:p-6 lg:p-8">
              <div className="max-w-4xl mx-auto">
                <header className="text-center mb-8">
                  <h1 className="text-3xl sm:text-4xl font-bold text-gray-900">محلل البيانات الجغرافية</h1>
                  <p className="mt-2 text-lg text-gray-600">ارفع ملفك الجغرافي واحصل على تحليل إحصائي ووصفي فوري باستخدام الذكاء الاصطناعي</p>
                  <div className="mt-4 bg-white p-4 rounded-lg shadow-sm border border-gray-200 flex flex-wrap justify-center items-center gap-4">
                      <div className="text-right">
                          <p className="font-bold text-gray-800">تصميم: محمود عبد الرحمن</p>
                          <p className="text-sm text-gray-500">للتواصل والاستفسارات</p>
                      </div>
                      <div className="flex items-center gap-4">
                          <a href="mailto:test@example.com" className="bg-blue-100 text-blue-700 font-semibold py-2 px-4 rounded-lg flex items-center gap-2 hover:bg-blue-200 transition-colors">
                              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z" /><path d="M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z" /></svg>
                              البريد الإلكتروني
                          </a>
                           <div className="bg-gray-100 text-gray-700 font-semibold py-2 px-4 rounded-lg flex items-center gap-2">
                              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M2 3a1 1 0 011-1h2.153a1 1 0 01.986.836l.74 4.435a1 1 0 01-.54 1.06l-1.548.773a11.037 11.037 0 006.105 6.105l.774-1.548a1 1 0 011.059-.54l4.435.74a1 1 0 01.836.986V17a1 1 0 01-1 1h-2C7.82 18 2 12.18 2 5V3z" /></svg>
                              00966561318400
                          </div>
                          <a href="https://wa.me/966561318400" target="_blank" className="bg-green-100 text-green-700 font-semibold py-2 px-4 rounded-lg flex items-center gap-2 hover:bg-green-200 transition-colors">
                              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M18 10c0 3.866-3.582 7-8 7a8.832 8.832 0 01-4.33-1.137l-1.43.475A1 1 0 013.06 15.16l.476-1.43A6.975 6.975 0 012 10c0-3.866 3.582-7 8-7s8 3.134 8 7zm-2.93-4.086a1 1 0 00-1.342-.323l-.334.167a6.001 6.001 0 00-3.41-3.41l.167-.334a1 1 0 00-.323-1.342L8.42.42A1 1 0 007.293.06l-1.14 1.14a1 1 0 00.06 1.523C7.63 3.65 8 4.88 8 6c0 1.12-.37 2.35-1.787 3.277a1 1 0 00.06 1.523l1.14 1.14a1 1 0 001.127-.36l1.414-1.414a1 1 0 00.36-1.127C10.35 9.63 9.12 9.26 8 9.26c-1.12 0-2.35.37-3.277 1.787a1 1 0 001.523.06l1.14-1.14a1 1 0 00.36-1.127c.926-1.417.56-2.65.56-3.77 0-1.12.37-2.35 1.787-3.277a1 1 0 00-.06-1.523l-1.14-1.14a1 1 0 00-1.127.36L3.92 3.92a1 1 0 00-.36 1.127C4.486 6.464 5.26 7.56 6 8.5c.74.94 1.514 1.514 2.5 2.254.986.74 2.082 1.514 3.5 2.44a1 1 0 001.127-.36l1.414-1.414a1 1 0 00.06-1.523l-1.14-1.14a1 1 0 00-1.523-.06c-1.417.926-2.65.56-3.77.56-1.12 0-2.35-.37-3.277-1.787a1 1 0 00-.06-1.523l1.14-1.14a1 1 0 001.127-.36l1.414-1.414a1 1 0 00.36-1.127z" clipRule="evenodd" /></svg>
                              واتساب
                          </a>
                      </div>
                  </div>
                </header>

                <div className="bg-white p-6 rounded-xl shadow-md border border-gray-200 space-y-4">
                  <label htmlFor="file-upload" onDragOver={handleDragOver} onDragLeave={handleDragLeave} onDrop={handleDrop} className={`flex flex-col items-center justify-center w-full h-64 border-2 border-dashed rounded-lg cursor-pointer transition-colors duration-300 ${isDragging ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:bg-gray-100'}`}>
                    <div className="flex flex-col items-center justify-center pt-5 pb-6 text-center">
                      <svg className="w-10 h-10 mb-4 text-gray-500" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 20 16"><path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 13h3a3 3 0 0 0 0-6h-.025A5.56 5.56 0 0 0 16 6.5 5.5 5.5 0 0 0 5.207 5.021C5.137 5.017 5.071 5 5 5a4 4 0 0 0 0 8h2.167M10 15V6m0 0L8 8m2-2 2 2"/></svg>
                      {uploadedFile ? (
                          <p className="mb-2 text-sm text-green-700"><span className="font-semibold">تم رفع الملف:</span> {uploadedFile.name}</p>
                      ) : (
                          <p className="mb-2 text-sm text-gray-600"><span className="font-semibold">انقر للاختيار</span> أو قم بسحب وإفلات الملف هنا</p>
                      )}
                      <p className="text-xs text-gray-500">Shapefile (.zip), KML, KMZ, GeoJSON</p>
                    </div>
                    <input id="file-upload" type="file" className="hidden" onChange={(e) => handleFileChange(e.target.files)} accept=".zip,.kml,.kmz,.geojson,.json"/>
                  </label>
                  
                  {uploadedFile && (
                    <div className="animate-fade-in">
                      <label htmlFor="description" className="block text-sm font-medium text-gray-700 mb-1">
                        وصف طبيعة الطبقة (اختياري)
                      </label>
                      <textarea
                        id="description"
                        rows="3"
                        className="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500"
                        placeholder="مثال: شبكة الطرق الرئيسية في مدينة الرياض، أو قطع الأراضي السكنية في حي معين..."
                        value={userDescription}
                        onChange={(e) => setUserDescription(e.target.value)}
                      ></textarea>
                      <p className="text-xs text-gray-500 mt-1">هذا الوصف سيساعد الذكاء الاصطناعي على تقديم تحليل أكثر دقة.</p>
                      <button
                        onClick={handleStartAnalysis}
                        disabled={isLoading}
                        className="mt-4 w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:bg-gray-400 transition-colors"
                      >
                        بدء التحليل
                      </button>
                    </div>
                  )}
                </div>

                <div className="mt-8 space-y-6">
                  {isLoading && <ProgressBar text="جاري معالجة الملف وتحليل الإحصائيات..." />}
                  {error && <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg" role="alert"><strong className="font-bold">خطأ: </strong><span className="block sm:inline">{error}</span></div>}

                  {fileInfo && (
                    <>
                      <div className="bg-white p-6 rounded-xl shadow-md border border-gray-200 animate-fade-in">
                        <h2 className="text-2xl font-bold text-gray-800 mb-4">ملخص البيانات الهيكلية</h2>
                        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 text-gray-700">
                          <div className="bg-gray-50 p-4 rounded-lg"><p className="font-semibold">عدد الظاهرات:</p><p className="text-lg text-blue-600 font-mono">{fileInfo.featureCount}</p></div>
                          <div className="bg-gray-50 p-4 rounded-lg"><p className="font-semibold">نوع الظاهرات:</p><p className="text-lg text-blue-600 font-mono">{fileInfo.geometryType}</p></div>
                        </div>
                      </div>

                      {fileInfo.geographicContext && (
                         <div className="bg-white p-6 rounded-xl shadow-md border border-gray-200 animate-fade-in">
                            <h2 className="text-2xl font-bold text-gray-800 mb-4">السياق الجغرافي</h2>
                            <div className="bg-gray-50 p-4 rounded-lg space-y-2">
                                <div>
                                    <p className="font-semibold">المركز التقريبي للبيانات:</p>
                                    <p className="text-blue-600">{fileInfo.geographicContext.centerLocation}</p>
                                </div>
                                <div>
                                    <p className="font-semibold">الامتداد المكاني:</p>
                                    <p className="text-blue-600">{fileInfo.geographicContext.extent}</p>
                                </div>
                            </div>
                        </div>
                      )}
                      
                      {fileInfo.statisticalSummary && Object.keys(fileInfo.statisticalSummary).length > 0 && (
                        <>
                            <div className="bg-white p-6 rounded-xl shadow-md border border-gray-200 animate-fade-in">
                                <h2 className="text-2xl font-bold text-gray-800 mb-4">الملخص الإحصائي للمتغيرات</h2>
                                <div className="space-y-4">
                                    {Object.entries(fileInfo.statisticalSummary).map(([key, value]) => (
                                        <div key={key} className="bg-gray-50 p-4 rounded-lg">
                                            <h3 className="font-bold text-lg text-blue-700">{key} <span className="text-red-600 font-mono">{value.type}</span></h3>
                                            <div className="mt-2 grid grid-cols-2 md:grid-cols-3 gap-x-4 gap-y-1 text-sm">
                                                <p><strong>العدد:</strong> {value.count}</p>
                                                <p><strong>الاكتمال:</strong> {value.completeness}%</p>
                                                {value.type === 'رقمي' && (<>
                                                    <p><strong>المتوسط:</strong> {value.mean}</p>
                                                    <p><strong>أقل قيمة:</strong> {value.min}</p>
                                                    <p><strong>أعلى قيمة:</strong> {value.max}</p>
                                                    <p><strong>الانحراف المعياري:</strong> {value.stdDev}</p>
                                                </>)}
                                                {value.type === 'نصي/فئوي' && (<>
                                                    <p><strong>القيم الفريدة:</strong> {value.uniqueValues}</p>
                                                </>)}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                            <SummaryChart summary={fileInfo.statisticalSummary} />
                        </>
                      )}
                    </>
                  )}

                  {(isAiLoading || aiResponse) && (
                    <div className="bg-sky-50 p-6 rounded-xl shadow-md border border-sky-200 animate-fade-in relative">
                      <div className="flex justify-between items-center mb-4">
                        <h2 className="text-2xl font-bold text-sky-800">تحليل الذكاء الاصطناعي</h2>
                        <div className="flex items-center space-x-2">
                            <button onClick={handleCopy} className="bg-sky-100 text-sky-700 hover:bg-sky-200 rounded-md p-2 transition-colors duration-200 flex items-center">
                                {isCopied ? (<><svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 ml-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7" /></svg>تم النسخ!</>) : (<><svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 ml-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>نسخ</>)}
                            </button>
                            <button onClick={handleExportToWord} className="bg-sky-100 text-sky-700 hover:bg-sky-200 rounded-md p-2 transition-colors duration-200 flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 ml-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
                                تصدير Word
                            </button>
                        </div>
                      </div>
                      {isAiLoading ? (
                         <ProgressBar text="يقوم الذكاء الاصطناعي بتحليل بياناتك... قد يستغرق هذا بضع لحظات." />
                      ) : (
                        <div dir="rtl">
                            <SimpleMarkdownRenderer text={aiResponse} />
                        </div>
                      )}
                    </div>
                  )}
                </div>
                
                <footer className="text-center mt-12 text-sm text-gray-500">
                    <p>يعمل التطبيق بالكامل في متصفحك لحماية خصوصيتك.</p>
                </footer>
              </div>
            </div>
          );
        };

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
